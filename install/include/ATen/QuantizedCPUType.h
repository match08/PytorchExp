#pragma once

// @generated by aten/src/ATen/gen.py

#include <ATen/Context.h>
#include <ATen/Utils.h>



namespace at {

struct QuantizedCPUType final {
  static Tensor as_strided(const Tensor & self, IntArrayRef size, IntArrayRef stride, c10::optional<int64_t> storage_offset);
  static Tensor _empty_affine_quantized(IntArrayRef size, const TensorOptions & options, double scale, int64_t zero_point, c10::optional<MemoryFormat> memory_format);
  static Tensor quantized_max_pool2d(const Tensor & self, IntArrayRef kernel_size, IntArrayRef stride, IntArrayRef padding, IntArrayRef dilation);
  static Tensor relu(const Tensor & self);
  static Tensor clone(const Tensor & self);
  static Tensor dequantize(const Tensor & self);
  static double q_scale(const Tensor & self);
  static int64_t q_zero_point(const Tensor & self);
  static Tensor int_repr(const Tensor & self);
  static QScheme qscheme(const Tensor & self);
  static Tensor & set_(Tensor & self, Storage source, int64_t storage_offset, IntArrayRef size, IntArrayRef stride);
  static Tensor & set_quantizer_(Tensor & self, ConstQuantizerPtr quantizer);
  static Tensor view(const Tensor & self, IntArrayRef size);
  static Tensor min(const Tensor & self);
  static Tensor max(const Tensor & self);
  static std::tuple<Tensor,Tensor> sort(const Tensor & self, int64_t dim, bool descending);
  static Tensor & adaptive_avg_pool2d_out(Tensor & out, const Tensor & self, IntArrayRef output_size);
  static Tensor _adaptive_avg_pool2d(const Tensor & self, IntArrayRef output_size);
};

} // namespace at
